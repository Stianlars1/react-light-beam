{"version":3,"sources":["../node_modules/@gsap/react/src/index.js","../src/hooks/useDarkmode.tsx","../src/index.tsx"],"names":["useLayoutEffect","useEffect","gsap","useRef","useState","ScrollTrigger","jsx"],"mappings":";;;;;;;;;;;AAaA,IAAI,yBAAA,GAA4B,OAAO,QAAA,KAAa,WAAA,GAAcA,qBAAA,GAAkBC,eAAA;AAApF,IACI,QAAA,GAAW,WAAS,KAAA,IAAS,CAAC,MAAM,OAAA,CAAQ,KAAK,CAAA,IAAK,OAAO,KAAA,KAAW,QAAA;AAD5E,IAEI,aAAa,EAAC;AAFlB,IAGI,gBAAgB,EAAC;AAHrB,IAII,KAAA,GAAQC,sBAAA;AAEL,IAAM,OAAA,GAAU,CAAC,QAAA,EAAU,YAAA,GAAe,UAAA,KAAe;AAC9D,EAAA,IAAI,MAAA,GAAS,aAAA;AACb,EAAA,IAAI,QAAA,CAAS,QAAQ,CAAA,EAAG;AACtB,IAAA,MAAA,GAAS,QAAA;AACT,IAAA,QAAA,GAAW,IAAA;AACX,IAAA,YAAA,GAAe,cAAA,IAAkB,MAAA,GAAS,MAAA,CAAO,YAAA,GAAe,UAAA;AAAA,EAClE,CAAA,MAAA,IAAW,QAAA,CAAS,YAAY,CAAA,EAAG;AACjC,IAAA,MAAA,GAAS,YAAA;AACT,IAAA,YAAA,GAAe,cAAA,IAAkB,MAAA,GAAS,MAAA,CAAO,YAAA,GAAe,UAAA;AAAA,EAClE;AACA,EAAC,YAAY,OAAO,QAAA,KAAa,UAAA,IAAe,OAAA,CAAQ,KAAK,qDAAqD,CAAA;AAClH,EAAA,MAAM,EAAE,KAAA,EAAO,cAAA,EAAe,GAAI,MAAA,EAC5B,OAAA,GAAUC,YAAA,CAAO,KAAK,CAAA,EACtB,OAAA,GAAUA,YAAA,CAAO,KAAA,CAAM,QAAQ,MAAM;AAAA,EAAE,GAAG,KAAK,CAAC,GAChD,WAAA,GAAcA,YAAA,CAAO,CAAC,IAAA,KAAS,OAAA,CAAQ,QAAQ,GAAA,CAAI,IAAA,EAAM,IAAI,CAAC,CAAA,EAC9D,eAAe,YAAA,IAAgB,YAAA,CAAa,UAAU,CAAC,cAAA;AAC7D,EAAA,YAAA,IAAgB,0BAA0B,MAAM;AAC9C,IAAA,OAAA,CAAQ,OAAA,GAAU,IAAA;AAClB,IAAA,OAAO,MAAM,OAAA,CAAQ,OAAA,CAAQ,MAAA,EAAO;AAAA,EACtC,GAAG,UAAU,CAAA;AACb,EAAA,yBAAA,CAA0B,MAAM;AAC9B,IAAA,QAAA,IAAY,OAAA,CAAQ,OAAA,CAAQ,GAAA,CAAI,QAAA,EAAU,KAAK,CAAA;AAC/C,IAAA,IAAI,CAAC,YAAA,IAAgB,CAAC,OAAA,CAAQ,OAAA,EAAS;AACrC,MAAA,OAAO,MAAM,OAAA,CAAQ,OAAA,CAAQ,MAAA,EAAO;AAAA,IACtC;AAAA,EACF,GAAG,YAAY,CAAA;AACf,EAAA,OAAO,EAAE,OAAA,EAAS,OAAA,CAAQ,OAAA,EAAS,WAAA,EAAa,YAAY,OAAA,EAAQ;AACtE,CAAA;AACA,OAAA,CAAQ,WAAW,CAAA,IAAA,KAAQ;AAAE,EAAA,KAAA,GAAQ,IAAA;AAAM,CAAA;AAC3C,OAAA,CAAQ,QAAA,GAAW,IAAA;AC7CZ,IAAM,gBAAgB,MAAM;AACjC,EAAA,MAAM,CAAC,UAAA,EAAY,mBAAmB,CAAA,GAAIC,eAAS,KAAK,CAAA;AAExD,EAAAH,gBAAU,MAAM;AACd,IAAA,MAAM,UAAA,GAAa,MAAA,CAAO,UAAA,CAAW,8BAA8B,CAAA;AAEnE,IAAA,MAAM,eAAe,MAAM;AACzB,MAAA,mBAAA,CAAoB,WAAW,OAAO,CAAA;AAAA,IACxC,CAAA;AAGA,IAAA,mBAAA,CAAoB,WAAW,OAAO,CAAA;AAGtC,IAAA,UAAA,CAAW,gBAAA,CAAiB,UAAU,YAAY,CAAA;AAGlD,IAAA,OAAO,MAAM;AACX,MAAA,UAAA,CAAW,mBAAA,CAAoB,UAAU,YAAY,CAAA;AAAA,IACvD,CAAA;AAAA,EACF,CAAA,EAAG,EAAE,CAAA;AAEL,EAAA,OAAO,EAAE,UAAA,EAAW;AACtB,CAAA;ACjBAC,sBAAAA,CAAK,cAAA,CAAeG,6BAAe,OAAO,CAAA;AAI1C,IAAM,aAAA,GAAqC;AAAA,EACvC,MAAA,EAAQ,uCAAA;AAAA,EACR,KAAA,EAAO,sCAAA;AAAA,EACP,UAAA,EAAY,oDAAA;AAAA,EACZ,UAAA,EAAY,qBAAA;AAAA;AAAA,EACZ,UAAA,EAAY,MAAA;AAAA,EACZ,aAAA,EAAe,MAAA;AAAA,EACf,OAAA,EAAS,oBAAA;AAAA;AAAA,EACT,gBAAA,EAAkB,oDAAA;AAAA,EAClB,gBAAA,EAAkB,MAAA;AAAA,EAClB,aAAA,EAAe;AACnB,CAAA;AAEO,IAAM,YAAY,CAAC;AAAA,EACI,SAAA;AAAA,EACA,KAAA;AAAA,EACA,cAAA,GAAiB,kBAAA;AAAA,EACjB,aAAA,GAAgB,0BAAA;AAAA,EAChB,mBAAA,GAAsB,KAAA;AAAA,EACtB,SAAA,GAAY,CAAA;AAAA;AAAA,EACZ,MAAA,GAAS,KAAA;AAAA,EACT,EAAA,GAAK,MAAA;AAAA,EACL,QAAA,GAAW,MAAA;AAAA,EACX,aAAA;AAAA,EACA,oBAAA,GAAuB;AAC3B,CAAA,KAAsB;AAC5C,EAAA,MAAM,UAAA,GAAaF,aAAuB,IAAI,CAAA;AAC9C,EAAA,MAAM,EAAC,UAAA,EAAU,GAAI,aAAA,EAAc;AACnC,EAAA,MAAM,WAAA,GAAc,aAAa,aAAA,GAAgB,cAAA;AAGjD,EAAAF,gBAAU,MAAM;AACZ,IAAA,QAAA,IAAY,QAAA,EAAS;AAAA,EACzB,CAAA,EAAG,EAAE,CAAA;AAGL,EAAA,OAAA;AAAA,IACI,MAAM;AACF,MAAA,MAAM,UAAU,UAAA,CAAW,OAAA;AAC3B,MAAA,IAAI,CAAC,OAAA,IAAW,OAAO,MAAA,KAAW,WAAA,EAAa;AAG/C,MAAA,MAAM,UAAA,GAAa,QAAA;AACnB,MAAA,MAAM,YAAA,GAAe,QAAA;AAIrB,MAAA,MAAM,qBAAA,GAAwB,CAAC,QAAA,EAAkB,KAAA,KAA0B;AAGvE,QAAA,MAAM,OAAA,GAAU,KAAK,QAAA,GAAW,EAAA;AAChC,QAAA,MAAM,QAAA,GAAW,KAAK,QAAA,GAAW,EAAA;AACjC,QAAA,MAAM,QAAA,GAAW,MAAM,QAAA,GAAW,EAAA;AAElC,QAAA,OAAO,CAAA,6BAAA,EAAgC,OAAO,CAAA,MAAA,EAAS,KAAK,qCAAqC,QAAQ,CAAA,2CAAA,EAA8C,QAAQ,CAAA,0BAAA,EAA6B,KAAK,CAAA,8BAAA,CAAA;AAAA,MACrM,CAAA;AAIA,MAAA,MAAM,eAAA,GAAkB,CAAC,QAAA,EAAkB,KAAA,KAA0B;AACjE,QAAA,IAAI,CAAC,mBAAA,EAAqB;AACtB,UAAA,OAAO,8BAA8B,KAAK,CAAA,sBAAA,CAAA;AAAA,QAC9C;AACA,QAAA,MAAM,SAAA,GAAY,KAAK,QAAA,GAAW,EAAA;AAClC,QAAA,OAAO,CAAA,2BAAA,EAA8B,KAAK,CAAA,iBAAA,EAAoB,SAAS,CAAA,EAAA,CAAA;AAAA,MAC3E,CAAA;AAGA,MAAA,MAAM,iBAAA,GAAoB,CAAC,WAAA,KAAgC;AAGvD,QAAA,MAAM,OAAA,GAAU,KAAK,GAAA,CAAI,CAAA,EAAG,KAAK,GAAA,CAAI,CAAA,EAAG,WAAW,CAAC,CAAA;AASpD,QAAA,OAAA,CAAQ,MAAA,GAAS,CAAA,GAAI,OAAA,GAAU,OAAA,IAAW,SAAA;AAAA,MAC9C,CAAA;AAKA,MAAA,MAAM,QAAA,GAAW,gBACV,aAAA,GACD,MAAA;AAMN,MAAA,MAAM,WAAA,GAAc,CAAA,IAAA,EAAA,CAAQ,CAAA,GAAI,SAAA,IAAa,GAAG,CAAA,CAAA,CAAA;AAGhD,MAAA,MAAM,EAAA,GAAKI,4BAAc,MAAA,CAAO;AAAA,QAC5B,OAAA,EAAS,OAAA;AAAA,QACT,KAAA,EAAO,YAAA;AAAA;AAAA,QACP,GAAA,EAAK,WAAA;AAAA;AAAA,QACL,QAAA;AAAA,QACA,KAAA,EAAO,IAAA;AAAA;AAAA,QACP,QAAA,EAAU,CAAC,IAAA,KAAS;AAGhB,UAAA,IAAI,IAAA,CAAK,WAAW,CAAA,EAAG;AAEnB,YAAA,MAAM,QAAA,GAAW,kBAAkB,CAAC,CAAA;AACpC,YAAAH,sBAAAA,CAAK,IAAI,OAAA,EAAS;AAAA,cACd,UAAA,EAAY,qBAAA,CAAsB,QAAA,EAAU,WAAW,CAAA;AAAA,cACvD,OAAA,EAAS,aAAa,YAAA,GAAe,QAAA;AAAA,cACrC,SAAA,EAAW,eAAA,CAAgB,QAAA,EAAU,WAAW,CAAA;AAAA,cAChD,eAAA,EAAiB,eAAA,CAAgB,QAAA,EAAU,WAAW;AAAA,aACzD,CAAA;AAAA,UACL,CAAA,MAAA,IAAW,IAAA,CAAK,QAAA,GAAW,CAAA,EAAG;AAE1B,YAAA,MAAM,QAAA,GAAW,kBAAkB,CAAC,CAAA;AACpC,YAAAA,sBAAAA,CAAK,IAAI,OAAA,EAAS;AAAA,cACd,UAAA,EAAY,qBAAA,CAAsB,QAAA,EAAU,WAAW,CAAA;AAAA,cACvD,OAAA,EAAS,aAAa,YAAA,GAAe,QAAA;AAAA,cACrC,SAAA,EAAW,eAAA,CAAgB,QAAA,EAAU,WAAW,CAAA;AAAA,cAChD,eAAA,EAAiB,eAAA,CAAgB,QAAA,EAAU,WAAW;AAAA,aACzD,CAAA;AAAA,UACL,CAAA,MAAO;AAEH,YAAA,MAAM,QAAA,GAAW,iBAAA,CAAkB,IAAA,CAAK,QAAQ,CAAA;AAChD,YAAAA,sBAAAA,CAAK,IAAI,OAAA,EAAS;AAAA,cACd,UAAA,EAAY,qBAAA,CAAsB,QAAA,EAAU,WAAW,CAAA;AAAA,cACvD,OAAA,EAAS,aAAa,YAAA,GAAe,QAAA;AAAA,cACrC,SAAA,EAAW,eAAA,CAAgB,QAAA,EAAU,WAAW,CAAA;AAAA,cAChD,eAAA,EAAiB,eAAA,CAAgB,QAAA,EAAU,WAAW;AAAA,aACzD,CAAA;AAAA,UACL;AAAA,QACJ,CAAA;AAAA,QACA,SAAA,EAAW,CAAC,IAAA,KAAS;AAEjB,UAAA,MAAM,QAAA,GAAW,iBAAA,CAAkB,IAAA,CAAK,QAAQ,CAAA;AAChD,UAAAA,sBAAAA,CAAK,IAAI,OAAA,EAAS;AAAA,YACd,UAAA,EAAY,qBAAA,CAAsB,QAAA,EAAU,WAAW,CAAA;AAAA,YACvD,OAAA,EAAS,aAAa,YAAA,GAAe,QAAA;AAAA,YACrC,SAAA,EAAW,eAAA,CAAgB,QAAA,EAAU,WAAW,CAAA;AAAA,YAChD,eAAA,EAAiB,eAAA,CAAgB,QAAA,EAAU,WAAW;AAAA,WACzD,CAAA;AAAA,QACL;AAAA,OACH,CAAA;AAGD,MAAA,MAAM,eAAA,GAAkB,iBAAA,CAAkB,EAAA,CAAG,QAAQ,CAAA;AACrD,MAAAA,sBAAAA,CAAK,IAAI,OAAA,EAAS;AAAA,QACd,UAAA,EAAY,qBAAA,CAAsB,eAAA,EAAiB,WAAW,CAAA;AAAA,QAC9D,OAAA,EAAS,aAAa,YAAA,GAAe,eAAA;AAAA,QACrC,SAAA,EAAW,eAAA,CAAgB,eAAA,EAAiB,WAAW,CAAA;AAAA,QACvD,eAAA,EAAiB,eAAA,CAAgB,eAAA,EAAiB,WAAW;AAAA,OAChE,CAAA;AAID,MAAA,UAAA,CAAW,MAAM;AACb,QAAAG,2BAAA,CAAc,OAAA,EAAQ;AAAA,MAC1B,GAAG,GAAG,CAAA;AAAA,IACV,CAAA;AAAA,IACA;AAAA,MAEI,YAAA,EAAc;AAAA,QACV,WAAA;AAAA,QACA,SAAA;AAAA,QACA,MAAA;AAAA,QACA,mBAAA;AAAA,QACA;AAAA,OACJ;AAAA,MACA,KAAA,EAAO;AAAA;AACX,GACJ;AAEA,EAAA,MAAM,iBAAA,GAAoB,CAAA,iBAAA,EAAoB,SAAA,IAAa,EAAE,GAAG,IAAA,EAAK;AAGrE,EAAA,MAAM,cAAc,oBAAA,GACd;AAAA;AAAA,IAEE,UAAA,EAAY,qBAAA;AAAA,IACZ,OAAA,EAAS,oBAAA;AAAA,IACT,GAAG;AAAA;AAAA,GACP,GACE;AAAA;AAAA,IAEE,GAAG,aAAA;AAAA,IACH,GAAG;AAAA;AAAA,GACP;AAEJ,EAAA,uBACIC,cAAA;AAAA,IAAC,KAAA;AAAA,IAAA;AAAA,MACG,GAAA,EAAK,UAAA;AAAA,MACL,SAAA,EAAW,iBAAA;AAAA,MACX,KAAA,EAAO,WAAA;AAAA,MACN,GAAI,EAAA,GAAK,EAAC,EAAA,KAAM;AAAC;AAAA,GACtB;AAER","file":"index.js","sourcesContent":["/*!\n * @gsap/react 2.1.2\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\nimport { useEffect, useLayoutEffect, useRef } from \"react\";\nimport gsap from \"gsap\";\n\nlet useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? useLayoutEffect : useEffect,\n    isConfig = value => value && !Array.isArray(value) && typeof(value) === \"object\",\n    emptyArray = [],\n    defaultConfig = {},\n    _gsap = gsap; // accommodates situations where different versions of GSAP may be loaded, so a user can gsap.registerPlugin(useGSAP);\n\nexport const useGSAP = (callback, dependencies = emptyArray) => {\n  let config = defaultConfig;\n  if (isConfig(callback)) {\n    config = callback;\n    callback = null;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  } else if (isConfig(dependencies)) {\n    config = dependencies;\n    dependencies = \"dependencies\" in config ? config.dependencies : emptyArray;\n  }\n  (callback && typeof callback !== \"function\") && console.warn(\"First parameter must be a function or config object\");\n  const { scope, revertOnUpdate } = config,\n        mounted = useRef(false),\n        context = useRef(_gsap.context(() => { }, scope)),\n        contextSafe = useRef((func) => context.current.add(null, func)),\n        deferCleanup = dependencies && dependencies.length && !revertOnUpdate;\n  deferCleanup && useIsomorphicLayoutEffect(() => {\n    mounted.current = true;\n    return () => context.current.revert();\n  }, emptyArray);\n  useIsomorphicLayoutEffect(() => {\n    callback && context.current.add(callback, scope);\n    if (!deferCleanup || !mounted.current) { // React renders bottom-up, thus there could be hooks with dependencies that run BEFORE the component mounts, thus cleanup wouldn't occur since a hook with an empty dependency Array would only run once the component mounts.\n      return () => context.current.revert();\n    }\n  }, dependencies);\n  return { context: context.current, contextSafe: contextSafe.current };\n};\nuseGSAP.register = core => { _gsap = core; };\nuseGSAP.headless = true; // doesn't require the window to be registered.\n","\"use client\";\nimport { useEffect, useState } from \"react\";\n\nexport const useIsDarkmode = () => {\n  const [isDarkmode, setIsDarkmodeActive] = useState(false);\n\n  useEffect(() => {\n    const matchMedia = window.matchMedia(\"(prefers-color-scheme: dark)\");\n\n    const handleChange = () => {\n      setIsDarkmodeActive(matchMedia.matches);\n    };\n\n    // Set the initial value\n    setIsDarkmodeActive(matchMedia.matches);\n\n    // Listen for changes\n    matchMedia.addEventListener(\"change\", handleChange);\n\n    // Cleanup listener on unmount\n    return () => {\n      matchMedia.removeEventListener(\"change\", handleChange);\n    };\n  }, []);\n\n  return { isDarkmode };\n};\n","\"use client\";\nimport gsap from \"gsap\";\nimport {ScrollTrigger} from \"gsap/ScrollTrigger\";\nimport {useGSAP} from \"@gsap/react\";\nimport React, {useEffect, useRef} from \"react\";\nimport {LightBeamProps} from \"../types/types\";\nimport {useIsDarkmode} from \"./hooks/useDarkmode\";\n\n// Register GSAP plugins\ngsap.registerPlugin(ScrollTrigger, useGSAP);\n\n// Default inline styles using CSS variables for easy customization\n// Users can override via className by setting CSS variables\nconst defaultStyles: React.CSSProperties = {\n    height: \"var(--react-light-beam-height, 500px)\",\n    width: \"var(--react-light-beam-width, 100vw)\",\n    transition: \"var(--react-light-beam-transition, all 0.25s ease)\",\n    willChange: \"background, opacity\", // Specific properties for better performance\n    userSelect: \"none\",\n    pointerEvents: \"none\",\n    contain: \"layout style paint\", // CSS containment for better performance\n    WebkitTransition: \"var(--react-light-beam-transition, all 0.25s ease)\",\n    WebkitUserSelect: \"none\",\n    MozUserSelect: \"none\",\n};\n\nexport const LightBeam = ({\n                              className,\n                              style,\n                              colorLightmode = \"rgba(0,0,0, 0.5)\",\n                              colorDarkmode = \"rgba(255, 255, 255, 0.5)\",\n                              maskLightByProgress = false,\n                              fullWidth = 1.0, // Default to full width\n                              invert = false,\n                              id = undefined,\n                              onLoaded = undefined,\n                              scrollElement,\n                              disableDefaultStyles = false,\n                          }: LightBeamProps) => {\n    const elementRef = useRef<HTMLDivElement>(null);\n    const {isDarkmode} = useIsDarkmode();\n    const chosenColor = isDarkmode ? colorDarkmode : colorLightmode;\n\n    // Call onLoaded callback when component mounts\n    useEffect(() => {\n        onLoaded && onLoaded();\n    }, []);\n\n    // GSAP ScrollTrigger implementation\n    useGSAP(\n        () => {\n            const element = elementRef.current;\n            if (!element || typeof window === \"undefined\") return;\n\n            // Pre-calculate constants for performance\n            const opacityMin = 0.839322;\n            const opacityRange = 0.160678; // 1 - 0.839322\n\n            // Helper function to interpolate background gradient\n            // NOTE: Takes color as parameter to always use current value (not closure!)\n            const interpolateBackground = (progress: number, color: string): string => {\n                // At progress 0: gradients are wide (90% and 10% positions)\n                // At progress 1: gradients converge (0% and 100% positions)\n                const leftPos = 90 - progress * 90; // 90% → 0%\n                const rightPos = 10 + progress * 90; // 10% → 100%\n                const leftSize = 150 - progress * 50; // 150% → 100%\n\n                return `conic-gradient(from 90deg at ${leftPos}% 0%, ${color}, transparent 180deg) 0% 0% / 50% ${leftSize}% no-repeat, conic-gradient(from 270deg at ${rightPos}% 0%, transparent 180deg, ${color}) 100% 0% / 50% 100% no-repeat`;\n            };\n\n            // Helper function to interpolate mask\n            // NOTE: Takes color as parameter to always use current value (not closure!)\n            const interpolateMask = (progress: number, color: string): string => {\n                if (!maskLightByProgress) {\n                    return `linear-gradient(to bottom, ${color} 25%, transparent 95%)`;\n                }\n                const stopPoint = 50 + progress * 45; // 50% → 95%\n                return `linear-gradient(to bottom, ${color} 0%, transparent ${stopPoint}%)`;\n            };\n\n            // Helper function to calculate progress from raw ScrollTrigger progress\n            const calculateProgress = (rawProgress: number): number => {\n                // ScrollTrigger gives us 0-1 as element moves from start to end\n                // Clamp to ensure it's always between 0 and 1\n                const clamped = Math.max(0, Math.min(1, rawProgress));\n\n                // Scale by fullWidth to control maximum beam width\n                // fullWidth=1.0 → progress goes 0 to 1 (fully wide)\n                // fullWidth=0.5 → progress goes 0 to 0.5 (50% wide max)\n                // fullWidth=0.2 → progress goes 0 to 0.2 (20% wide max)\n\n                // Default (invert=false): 0→fullWidth = small to wide\n                // Inverted (invert=true): fullWidth→0 = wide to small\n                return (invert ? 1 - clamped : clamped) * fullWidth;\n            };\n\n            // Determine scroll container\n            // ScrollTrigger expects undefined (default), window, or a DOM element\n            // If scrollElement is provided, cast it as Element (GSAP accepts Element or Window)\n            const scroller = scrollElement\n                ? (scrollElement as Element | Window)\n                : undefined;\n\n            // Calculate end position based on fullWidth\n            // fullWidth=1.0 → end=\"top 0%\" (animates through entire viewport)\n            // fullWidth=0.5 → end=\"top 50%\" (stops animation halfway)\n            // fullWidth=0.0 → end=\"top 100%\" (no animation)\n            const endPosition = `top ${(1 - fullWidth) * 100}%`;\n\n            // Create ScrollTrigger\n            const st = ScrollTrigger.create({\n                trigger: element,\n                start: \"top bottom\", // Start when element enters viewport from bottom\n                end: endPosition, // End position based on fullWidth prop\n                scroller: scroller,\n                scrub: true, // TRUE for instant scrubbing (no lag) - smoother bidirectional\n                onUpdate: (self) => {\n                    // CRITICAL: Only animate while INSIDE the trigger range\n                    // Once past the end, lock at final value\n                    if (self.progress < 0) {\n                        // Before start - lock at 0%\n                        const progress = calculateProgress(0);\n                        gsap.set(element, {\n                            background: interpolateBackground(progress, chosenColor),\n                            opacity: opacityMin + opacityRange * progress,\n                            maskImage: interpolateMask(progress, chosenColor),\n                            webkitMaskImage: interpolateMask(progress, chosenColor),\n                        });\n                    } else if (self.progress > 1) {\n                        // Past end - lock at 100%\n                        const progress = calculateProgress(1);\n                        gsap.set(element, {\n                            background: interpolateBackground(progress, chosenColor),\n                            opacity: opacityMin + opacityRange * progress,\n                            maskImage: interpolateMask(progress, chosenColor),\n                            webkitMaskImage: interpolateMask(progress, chosenColor),\n                        });\n                    } else {\n                        // Inside range - animate normally\n                        const progress = calculateProgress(self.progress);\n                        gsap.set(element, {\n                            background: interpolateBackground(progress, chosenColor),\n                            opacity: opacityMin + opacityRange * progress,\n                            maskImage: interpolateMask(progress, chosenColor),\n                            webkitMaskImage: interpolateMask(progress, chosenColor),\n                        });\n                    }\n                },\n                onRefresh: (self) => {\n                    // Set initial state when ScrollTrigger refreshes\n                    const progress = calculateProgress(self.progress);\n                    gsap.set(element, {\n                        background: interpolateBackground(progress, chosenColor),\n                        opacity: opacityMin + opacityRange * progress,\n                        maskImage: interpolateMask(progress, chosenColor),\n                        webkitMaskImage: interpolateMask(progress, chosenColor),\n                    });\n                },\n            });\n\n            // Set initial state immediately\n            const initialProgress = calculateProgress(st.progress);\n            gsap.set(element, {\n                background: interpolateBackground(initialProgress, chosenColor),\n                opacity: opacityMin + opacityRange * initialProgress,\n                maskImage: interpolateMask(initialProgress, chosenColor),\n                webkitMaskImage: interpolateMask(initialProgress, chosenColor),\n            });\n\n            // Refresh ScrollTrigger after a brief delay to ensure layout is settled\n            // This is especially important for Next.js SSR/hydration\n            setTimeout(() => {\n                ScrollTrigger.refresh();\n            }, 100);\n        },\n        {\n            \n            dependencies: [\n                chosenColor,\n                fullWidth,\n                invert,\n                maskLightByProgress,\n                scrollElement,\n            ],\n            scope: elementRef,\n        }\n    );\n\n    const combinedClassName = `react-light-beam ${className || \"\"}`.trim();\n\n    // Prepare final styles (same logic as before, just without MotionValues)\n    const finalStyles = disableDefaultStyles\n        ? {\n            // No default styles, only user styles\n            willChange: \"background, opacity\",\n            contain: \"layout style paint\",\n            ...style, // User styles override\n        }\n        : {\n            // Merge default styles with user styles\n            ...defaultStyles,\n            ...style, // User styles override everything\n        };\n\n    return (\n        <div\n            ref={elementRef}\n            className={combinedClassName}\n            style={finalStyles}\n            {...(id ? {id} : {})}\n        />\n    );\n};\n"]}